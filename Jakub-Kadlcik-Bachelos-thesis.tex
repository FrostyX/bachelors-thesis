\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage[T1]{fontenc}

\title{Determine applications affected by upgrade}
\author{Jakub Kadlčík}

\begin{document}
	% Vazba
	\maketitle
	\newpage

	% Anotace

	% Poděkování

	\tableofcontents
	\newpage

	\section{Úvod}
		\subsection{Správa software v GNU/Linux}
		Ve většině distribucí GNU/Linuxu se software standardně spravuje prostřednictvím balíčkovacího systému. Nové distribuce většinou vznikají odvozením jiné, již existující distribuce a v tomto případě bývá zachován typ balíčků i balíčkovací systém. Můžeme tedy říct, že distribucí je mnoho, ale balíčkovaích systémů se používá jen velmi málo. Konkrétně lze hovořit o distribucích GNU/Linuxu používající balíčky RPM\footnote{RPM = Red Hat Package Manager}, DEB\footnote{DEB = Debian software package} a nebo jiný typ balíčku. V posledním případě se jedná případ od případu o velmi specifický předpis balíčku. V rámci této práce se budeme zabývat linuxovou distribucí Fedora jako reprezentantem první skupiny a distribucí Gentoo, jako reprezentantem poslední skupiny.

		\subsection{Balíčkovací systém distribuce Fedora}
		Fedora vznikla jako nekomerční odnož Red Hat Linuxu a zachovala stávající systém balíčků RPM\@. Od své první verze využívá nástavbu nad RPM zvanou YUM\@. Ten se po čase stal téměř neudržovatelný a proto se objevila alternativa pojmenovaná DNF\@. V současné době lze paralelně využívat oba tyto nástroje, avšak je snaha YUM kompletně nahradit za pomocí DNF\@. Mělo by k tomu dojít již ve Fedoře 21. Aktuální stabilní verze je 20, jde tedy o příští vydání.

		\subsection{Balíčkovací systém distribuce Gentoo}

	\section{Problém}
	Když spustíme aplikaci, do paměti se načtou knihovny a soubory potřebné k jejímu běhu. Pokud je některá z knihoven, nebo samotná aplikace po dobu jejího běhu aktualizována, v paměti stále zůstanou původní soubory, přestože fyzicky už nemusí existovat (mohou být smazány, nebo nahrazeny novějšími verzemi).
	\\\\
	Zjistit, které, v systému spuštěné, aplikace využívají takto neaktuální soubory, není pro uživatele triviální. V současné době sice existují nástroje, které tento problém řeší, avšak jsou z mnoha důvodů nedostatečné.

	\section{Požadavky}
	Tato práce si klade za cíl vytvořit aplikaci, která bude řešit dříve zmíněný problém. Aplikace by měla najít všechny programy využívající neaktuální soubory a doporučit jejich restartování. Pro různé typy programů by měla být vypsána jiná doporučení a nápověda, jakým způsobem to lze provést. Aplikace by měla disponovat textovým uživatelským rozhraním a mělo by být možné ji používat jako modul přímo v balíčkovacím systému DNF\@. Vývoj by měl probíhat pod otevřenou licencí a na libovolném veřejném úložišti. Dále by měl být k dispozici instalační balíček pro distribuci Fedora.

	\section{Analýza}
	Rozložme si problém na menší části a projděme je jednu po druhé. Stěžení částí aplikace má být vypsání jistého seznamu aplikací. Nejdříve se tedy zaměříme na jeho získání. Dále potřebujeme konstrukt, který zjistí informace o  dané aplikaci. Nakonec nás bude zajímat zjištění způsobu, jak aplikaci restartovat.
	
		\subsection{Získání seznamu ovlivněných aplikací}
		Stěžejní část aplikace. [..] Nabízí se přímočaré řešení. Zjistit seznam balíčků, které byly od spuštění systému modifikovány. Následně pro každý balíček zjistit seznam souborů, které poskytuje. Poté zjistit, které procesy využívají některý z množiny modifikovaných souborů. Tedy pro každý spuštěný proces zjistit seznam souborů jež využívá a najít shodu s modifikovanými balíčky.
		
		\begin{verbatim}
		packages = seznam balíčků modifikovaných od spuštění systému
		processes = seznam všech spuštěných procesů
		for package in packages:
		    for process in processes:
		        if množinový_průnik(package_files, process_files) != prázdná množina
		            print process
		\end{verbatim}
		
		Algoritmus na první pohled vypadá velmi jednoduše a zřejmě vypíše korektní množinu procesů. Mohlo by se tedy zdát, že máme hotovo, nicméně jsme nevzali v úvahu časovou složitost takového algoritmu. Ta je bohužel velmi nepříznivá, což by činilo vyhledávání útrpně pomalé.
		
		% vypočítání složitosti
		% Vysvětlení a ukázka kódu množinového průniku
		
		Klíčem k rychlejšímu získání chtěných procesů je zvolení vhodné vyhledávací struktury pro data. Vezměme si fakt, že mnoho procesů využívá stejné soubory (knihovny, etc). Naivní algoritmus tedy jeden konkrétní soubor musí ověřit hned několikrát - pro každý proces, který jej využívá.
		
		Tento nedostatek můžeme řešit tak, že nebudueme zkoumat proces po procesu, ale místo toho vezmeme množinu všech\footnote{} souborů v paměti, přičemž ke každému si poznačíme procesy, které jej využívají. Pro nejrychlejší možné vyhledávání v množině souborů, je budeme ukládat do vyhledávacího stromu typu BTree.
		
		\begin{verbatim}
		packages = seznam balíčků modifikovaných od spuštění systému
		processes_files = BTree(...)
		for package in packages:
		    for package_file in package_files:
		        processes = processes_files[package_file]
		        if processes != prázdná množina:
		            print processes
		\end{verbatim}
		
		% Výpočet složitosti algoritmu
		
		\subsection{Informace o aplikaci}
		Rozlišujme dva druhy informací. Pracujeme se spuštěnými aplikacemi, v tom případě lze hovořit o procesech spuštěných v systému. Každý proces má nějaký PID\footnote{}, spustil jej nějaký uživatel, běží určitou dobu, etc.
		
		Dále lze uvažovat, že každá\footnote{Každá standardně nainstalovaná} aplikace je poskytována některým balíčkem. Každý takový balíček poskytuje informace o tom, k čemu slouží, v jaké je verzi, jak dlouho je nainstalován, etc.
		
		Lze předpokládat, že informace o procesech budou získatelné jednotným způsobem napříč celým spektrem linuxových distribucí, avšak informace o balíčku budou závislé na jeho typu.
		
		\subsection{Jak aplikaci restartovat?} 
	
	\section{Implementace}
		\subsection{Úvod}
		Projekt je vyvíjen pod názvem tracer. Požadovalo se, aby byl implementován v jazyce Python. V současné době se nejčastěji pouužívá Python2.7, který lze nalézt na všech distribucích a pro který existuje velká spousta uživatelských knihoven. Z tohoto důvodu jsem zvolil právě verzi 2.7, přestože aktuální stabilní verzí je 3.x.		
		
		\subsection{Práce s procesy}
		Správu procesů v jazyce python zajišťuje balík psutil, který je ve Fedoře k dispozici pod názvem python-psutil. Umožňuje přístup ke všem atributům procesu, které lze v linuxových systémech zjistit. Mimo to poskytuje rozhraní pro získávání informací o paměti, procesoru, pevných discích a síťových rozhraních.		

		Nás ovšem zajímá pouze práce s procesy.

		\begin{verbatim}
		>>> import psutil
		>>> p = psutil.Process(pid)

		>>> p.pid
		13005

		>>> p.name
		'gvim'

		>>> p.username
		'frostyx'

		>>> p.create_time
		1408897172.2

		>>> p
		<psutil.Process(pid=13005, name='gvim') at 3071122124>

		\end{verbatim}
		
		Pokročilejší funkcí může být zjištění souborů, které proces využívá.
		
		\begin{verbatim}
		import psutil
		p = psutil.Process(pid)
		for mmap in p.get_memory_maps():
		    print mmap.path
		\end{verbatim}
				
		\subsection{Práce s balíčky}
		\subsection{DNF plugin}
		\subsection{Testování}

	\section{Distribuce programu}
		\subsection{Zdrojový kód}
		\subsection{Verzování}
		\subsection{Balíčky pro distribuce}
		\subsection{Dokumentace}
		\subsection{Licence}

	\section{Závěr} % Zrušit číslování
	\section{Conclusions} % Zrušit číslování
	\section{Reference} % Zrušit číslování

	% Obsah přiloženého CD
\end{document}
